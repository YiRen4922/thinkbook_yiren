# 环境搭建
# 文件IO
# LED编程
# GPIO编程

# 输入设备编程
# 串口编程
# PWM编程
# I2C编程
## [[I2C|协议基础]]
## I2C Tools
### 安装
```
sudo apt install i2c-tools
```
![使用](../../../image/系统编程-1756996895688.webp)
i2cdetect：
```
i2cdetect -l # list 列出可用总线机器编号
i2cdetect <bus_num> #扫描指定总线，i2cdetect 1，扫描总线1
i2cdetect -F <bus_num> #查看总线支持的功能
```
i2cdump：
```
i2cdump <bus_num> <i2c_address> # 读取寄存器，i2cdump 1 0x38
i2cdump -f <bus_num> <i2c_address> # 强制读取寄存器

i2cdump -f -r 0x80-0xff 1 0x38 # 读取部分寄存器（-r 0x80-0xff ）
```
i2cset：
```
i2cset -f 1  0x38 0x80 0x55 # i2cset <强制写入> <总线1>  <总线地址> <寄存器地址> <寄存器内容> 
```
i2cget：
```
i2cget -f 1 0x38 0x80 # <强制获取> <总线1>  <总线地址> <寄存器地址>
```

## I2C应用编程

伪代码流程：读取I2C设备指定寄存器的值
1. 打开I2C设备节点 (例如 /dev/i2c-1)
2. 准备一个i2c_rdwr_ioctl_data结构，它包含两个i2c_msg：
   - 第一个消息：设置写入模式，发送寄存器地址 (flags=0, 表示写)
   - 第二个消息：设置读取模式，准备接收数据 (flags=I2C_M_RD, 表示读)
3. 调用ioctl(fd, I2C_RDWR, &i2c_rdwr_ioctl_data) 一次性完成上述两次传输（包含重复起始位）
4. 处理读取到的数据
5. 关闭设备
简单I2C读写示例：
```c i2c_demo1.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <inttypes.h>

int main() {
    int file;
    const char *dev = "/dev/i2c-1";  // 使用 i2c-1 总线
    file = open(dev, O_RDWR); // 打开 I2C 设备

    if (file < 0) {
        perror("Failed to open the I2C bus");
        exit(1);
    }

    // 设定 I2C 从设备地址
    int addr = 0x68;  // 设备的 I2C 地址
    if (ioctl(file, I2C_SLAVE, addr) < 0) {
        perror("Failed to acquire bus access and/or talk to slave");
        exit(1);
    }

    // 进行读写操作
    unsigned char write_buffer[2]; 
	write_buffer[0] = 0x10; // 寄存器地址
	write_buffer[1] = 0x01; // 写入的值
	
	if (write(file, write_buffer, sizeof(write_buffer)) != sizeof(write_buffer)) {
	    perror("Failed to write to the I2C bus");
	    exit(1);
	}
	// 读
	unsigned char read_buffer[1]; 
	if (read(file, read_buffer, sizeof(read_buffer)) != sizeof(read_buffer)) {
	    perror("Failed to read from the I2C bus");
	    exit(1);
	}
	printf("Read value: 0x%02x\n", read_buffer[0]);

    close(file);
    return 0;
}

```

组合I2C读写示例：
```c i2c_demo2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <inttypes.h>
#include <linux/i2c.h>

int main() {
    int file;
    const char *dev = "/dev/i2c-1";  // 使用 i2c-1 总线
    file = open(dev, O_RDWR); // 打开 I2C 设备

    if (file < 0) {
        perror("Failed to open the I2C bus");
        exit(1);
    }

    // 设定 I2C 从设备地址
    int addr = 0x68;  // 设备的 I2C 地址
    if (ioctl(file, I2C_SLAVE, addr) < 0) {
        perror("Failed to acquire bus access and/or talk to slave");
        exit(1);
    }

    // 进行读写操作...

    // 写操作
    unsigned char write_buffer[2] = {0x10, 0x01};  // 寄存器地址和写入值
    struct i2c_msg msgs[1] = {
        {
            .addr  = addr,
            .flags = 0,  // 写操作
            .len   = sizeof(write_buffer),
            .buf   = write_buffer
        }
    };

    struct i2c_rdwr_ioctl_data rdwr_data = {
        .msgs = msgs,
        .nmsgs = 1
    };

    if (ioctl(file, I2C_RDWR, &rdwr_data) < 0) {
        perror("Failed to write using i2c_rdwr_ioctl_data");
        exit(1);
    }

    // 读操作
    unsigned char read_buffer[1];
    msgs[0] = (struct i2c_msg){
        .addr  = addr,
        .flags = I2C_M_RD,  // 读操作
        .len   = sizeof(read_buffer),
        .buf   = read_buffer
    };

    rdwr_data.msgs = msgs;
    rdwr_data.nmsgs = 1;

    if (ioctl(file, I2C_RDWR, &rdwr_data) < 0) {
        perror("Failed to read using i2c_rdwr_ioctl_data");
        exit(1);
    }

    printf("Read value: 0x%02x\n", read_buffer[0]);

    close(file);
    return 0;
}

```


# SPI编程
# Socket编程
# CAN编程

