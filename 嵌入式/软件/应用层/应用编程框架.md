Linux应用：在应用程序中调用系统调用API完成功能和逻辑，**应用程序运行于操作系统之上**

应用程序与驱动程序是分隔、分离的，它们单独编译，它们并不是整合在一起的，应用程序运行在操作系统之上，有操作系统支持，应用程序处于用户态，而驱动程序处于内核态，与纯粹的裸机程序存在着质的区别。


# 文件编程
## 文件IO（系统调用）
系统调用(system call)其实是**Linux内核提供给应用层的应用编程接口(API)**，是**Linux应用层进入内核的入口**。通过系统调用可完成如打开磁盘文件、读写文件、控制外设等。
- **核心函数**：`open()`（打开文件）、`close()`（关闭文件）、`read()`/`write()`（读写数据）、`lseek()`（调整文件偏移）、`stat()`/`fstat()`/`lstat()`（查询文件状态）。

## 标准IO（C语言库函数）
### 库函数
库函数也就是C语言库函数，C语言库是应用层使用的一套函数库，**在Linux下，通常以动态(.so)库文件的形式提供，存放在根文件系统/lib目录下**，C语言库函数构建于系统调用之上，也就是说库函数其实是由系统调用封装而来的，当然也有些库函数时不调用系统调用的。

**Linux系统内核提供了一系列的系统调用供应用层使用，直接使用系统调用就可以了**，但是**有些系统调用使用起来并不是很方便**，于是就出现了C语言库，这些**C语言库函数的设计是为了提供比底层系统调用更为方便、更为好用、且更具有可移植性的调用接口**。

两者的区别： - 库函数是属于应用层，而系统调用是内核提供给应用层的编程接口，属于系统内核的一部分； - 库函数运行在用户空间，调用系统调用会由用户空间（用户态）陷入到内核空间（内核态）； - 库函数通常是有缓存的，而系统调用是无缓存的，所以在性能、效率上，库函数通常要优于系统调用； - 可移植性：库函数相比于系统调用具有更好的可移植性。
### 标准 IO / 文件共享 / 文件锁

- **标准 IO 函数**：`fopen()`（打开流）、`fclose()`（关闭流）、`fread()`/`fwrite()`（流读写）、`fseek()`（流偏移）、`fprintf()`/`fscanf()`（格式化读写）。
- **文件共享与复制**：`dup()`（复制文件描述符）、`dup2()`（复制到指定描述符）。
- **文件锁**：`fcntl()`（通过`F_SETLK`等命令设置记录锁，使用`struct flock`结构体描述锁的范围 / 类型）。
## 其他API
## 高级IO
### 五种 I/O 模型（阻塞、非阻塞、I/O 多路复用等）

- **I/O 多路复用**：`select()`（监控多个描述符）、`poll()`（类似`select`，更灵活）、`epoll_create()`/`epoll_ctl()`/`epoll_wait()`（高效多路复用，适用于大并发）。
- **非阻塞 I/O 设置**：`fcntl()`（通过命令设置文件描述符为非阻塞）。

# 进程编程
## 进程控制

多进程
- **进程相关**：  
    函数：`fork()`（创建子进程）、`exec`系列（加载新程序，如`execl`/`execv`）、`wait()`/`waitpid()`（等待子进程结束）、`exit()`（进程退出）。




## 进程间通信

### 进程通信
支持管道、信号、共享内存、消息队列、信号量等方式：
- **管道**：`pipe()`（无名管道）、`mkfifo()`（有名管道）。
- **信号**：`kill()`（发送信号）、`sigaction()`/`signal()`（注册信号处理函数）。
- **共享内存**：`shmget()`（创建 / 获取共享内存）、`shmat()`（附加到进程地址空间）、`shmdt()`（分离）、`shmctl()`（控制共享内存）。
- **消息队列**：`msgget()`（创建 / 获取消息队列）、`msgsnd()`（发消息）、`msgrcv()`（收消息）、`msgctl()`（控制）。
- **信号量**：`semget()`（创建 / 获取信号量集）、`semop()`（信号量操作）、`semctl()`（控制）。
# 网络编程
## Socket编程
### Socket编程
- **核心函数**：`socket()`（创建套接字）、`bind()`（绑定地址端口）、`listen()`（监听连接）、`accept()`（接受连接）、`connect()`（发起连接）、`send()`/`recv()`（TCP 数据读写）、`sendto()`/`recvfrom()`（UDP 数据读写）、`close()`（关闭套接字）。
- **关键结构体**：`struct sockaddr_in`（IPv4 地址结构，包含端口、IP 等）、`struct addrinfo`（地址解析结果，用于`getaddrinfo()`）。
### 
# 获取系统信息
## 时间函数

- **核心函数**：`time()`（获取秒级时间戳）、`gettimeofday()`（获取微秒级时间）、`clock_gettime()`（纳秒级高精度时间）、`localtime()`/`gmtime()`（时间戳转 “年 / 月 / 日” 分解结构）、`mktime()`（分解时间转时间戳）、`strftime()`（时间格式化字符串）。
- **关键结构体**：`struct timeval`（秒 + 微秒，对应`gettimeofday()`）、`struct timespec`（秒 + 纳秒，对应`clock_gettime()`）、`struct tm`（分解时间结构，如年、月、日、时、分、秒）。
## 随机数
## 获取内核信息


# 多线程
## 常见函数
### 多线程
- **线程相关**：  
    函数：`pthread_create()`（创建线程）、`pthread_join()`（等待线程结束）、`pthread_exit()`（线程退出）、`pthread_detach()`（分离线程）。  
    结构体：`pthread_t`（线程 ID 类型）、`pthread_attr_t`（线程属性配置）。
## 线程同步

### 线程同步

解决多线程竞争问题，常用同步原语：
- **互斥量**：`pthread_mutex_init()`（初始化）、`pthread_mutex_lock()`（加锁）、`pthread_mutex_unlock()`（解锁）、`pthread_mutex_destroy()`（销毁）。
- **条件变量**：`pthread_cond_init()`（初始化）、`pthread_cond_wait()`（等待条件）、`pthread_cond_signal()`（唤醒一个等待线程）、`pthread_cond_broadcast()`（唤醒所有等待线程）。
- **读写锁**：`pthread_rwlock_init()`（初始化）、`pthread_rwlock_rdlock()`（读加锁）、`pthread_rwlock_wrlock()`（写加锁）、`pthread_rwlock_unlock()`（解锁）。
- **关键结构体**：`pthread_mutex_t`（互斥量类型）、`pthread_cond_t`（条件变量类型）、`pthread_rwlock_t`（读写锁类型）。














